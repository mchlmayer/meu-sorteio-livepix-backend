// server.js - Seu servidor de backend para implantação

const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const fetch = require('node-fetch');

const app = express();
// Usa a porta fornecida pelo ambiente de hospedagem (ex: Render) ou 3001 localmente
const PORT = process.env.PORT || 3001;

// Configura o CORS. Em produção, substitua '*' pelo domínio exato da sua aplicação React
// Ex: cors({ origin: 'https://seusorteio.netlify.app' })
app.use(cors());

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Rota para Obter o Token de Acesso LivePix
app.post('/api/livepix/token', async (req, res) => {
  // OBTENDO CREDENCIAIS DE VARIÁVEIS DE AMBIENTE PARA SEGURANÇA EM PRODUÇÃO
  const clientId = process.env.LIVEPIX_CLIENT_ID;
  const clientSecret = process.env.LIVEPIX_CLIENT_SECRET;

  // Se estiver testando localmente e não configurou variáveis de ambiente,
  // você pode descomentar as linhas abaixo para pegar do corpo da requisição,
  // mas REMOVA ISSO ANTES DE PUBLICAR EM PRODUÇÃO por segurança.
  // const { clientId, clientSecret } = req.body;

  if (!clientId || !clientSecret) {
    return res.status(400).json({ error: 'ID do Cliente e Segredo do Cliente são obrigatórios no servidor.' });
  }

  try {
    const params = new URLSearchParams();
    params.append('grant_type', 'client_credentials');
    params.append('client_id', clientId);
    params.append('client_secret', clientSecret);
    params.append('scope', 'messages:read');

    const response = await fetch('https://oauth.livepix.gg/oauth2/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: params.toString(),
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error('Erro do LivePix OAuth:', errorData);
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    res.json(data);
  } catch (error) {
    console.error('Erro no proxy ao obter token:', error);
    res.status(500).json({ error: 'Erro interno do servidor ao obter token.' });
  }
});

// Rota para Buscar Mensagens (Doações) LivePix com Filtro de Período
app.get('/api/livepix/messages', async (req, res) => {
  const authHeader = req.headers.authorization;
  const { startDate, endDate } = req.query;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Token de acesso não fornecido ou inválido.' });
  }

  const accessToken = authHeader.split(' ')[1];

  try {
    const livepixApiUrl = `https://api.livepix.gg/v2/messages?limit=100`;

    const response = await fetch(livepixApiUrl, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      console.error('Erro do LivePix API:', errorData);
      return res.status(response.status).json(errorData);
    }

    const result = await response.json();
    let messages = result.data || [];

    if (startDate || endDate) {
      const start = startDate ? new Date(startDate + 'T00:00:00-03:00') : null;
      const end = endDate ? new Date(endDate + 'T23:59:59-03:00') : null;

      messages = messages.filter(msg => {
        const messageDate = new Date(msg.createdAt);

        let isAfterStart = true;
        if (start) {
          isAfterStart = messageDate >= start;
        }

        let isBeforeEnd = true;
        if (end) {
          isBeforeEnd = messageDate <= end;
        }

        return isAfterStart && isBeforeEnd;
      });
    }

    res.json({ data: messages });
  } catch (error) {
    console.error('Erro no proxy ao buscar mensagens:', error);
    res.status(500).json({ error: 'Erro interno do servidor ao buscar mensagens.' });
  }
});

app.listen(PORT, () => {
  console.log(`Servidor proxy rodando na porta ${PORT}`);
  console.log('Lembre-se de usar variáveis de ambiente para LIVEPIX_CLIENT_ID e LIVEPIX_CLIENT_SECRET em produção!');
});
